-- Output
local streamproof = true -- steamproof = rconsole , print = normal console (F9)
-- Farming
local fastmode = true
local lowgfx = true
local antiafk = true

-- End of configs
local EventHandler
local timeInfo = os.date("*t")
local version = "1.2"
if game.PlaceId == 192800 then

if streamproof then
  rconsolename("Auto-Cashier | Work at a pizza place | Version: " .. version .. "\n")
  rconsoleprint("Log: Script loaded.")
end
for i,v in pairs(getgc()) do
    if typeof(v) == "function" and islclosure(v) and not is_synapse_function(v) and debug.getinfo(v).name == "GetEventHandler" then
              if streamproof then
              rconsoleprint("Log: Customer Found\n")
             else
            print(timeInfo.hour .. ":" .. timeInfo.min.. " | Log: Customer Found")
        end
    EventHandler = v
  end
end

if antiafk then
local vu = game:GetService("VirtualUser")
game:GetService("Players").LocalPlayer.Idled:connect(function()
   vu:Button2Down(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
   wait(1)
   vu:Button2Up(Vector2.new(0,0),workspace.CurrentCamera.CFrame)
   end)
   if streamproof then
     rconsoleprint("Log: Anti-afk is on\n")
   else
     print(timeInfo.hour .. ":" .. timeInfo.min.. " | Log: Anti-Afk is on")
    end
end
local Table2 = getupvalue(EventHandler, 1)
for i,v in pairs(Table2) do
    if v.Remote then
        v.Remote.Name = i
    end
end

local LocalPlayer = game.Players.LocalPlayer
local Events = game:GetService("ReplicatedStorage"):WaitForChild("Communication"):WaitForChild("Events")
local function FindChildByIndexSequence(Parent, IndexSequence)
    local CurrentChild = Parent
    for _, Index in ipairs(IndexSequence) do
        CurrentChild = CurrentChild:FindFirstChild(tostring(Index))
        if not CurrentChild then
            return nil
        end
    end
    return CurrentChild
end

local function WalkToPoint(TargetPoint)
    local Humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    if Humanoid then
        Humanoid:MoveTo(TargetPoint)
    end
    return function()
        repeat wait() Humanoid:MoveTo(TargetPoint) until (LocalPlayer.Character.HumanoidRootPart.Position * Vector3.new(1,0,1) - TargetPoint * Vector3.new(1,0,1)).Magnitude < 2
    end
end

local function TeleportToJob(Name)
    local args = { 
        [1] = "TeleportToJob",
        [2] = Name
    }
    game:GetService("ReplicatedStorage"):WaitForChild("PlayerChannel"):FireServer(unpack(args))    
end

for i,v in pairs(getconnections(workspace.Main.GivePaycheck.OnClientEvent)) do
    v:Disable()
end

local function ClaimPaycheck()
    workspace:WaitForChild("Main"):WaitForChild("GivePaycheck"):FireServer("Paycheck", false)
end

local MainClass = {}
MainClass.CharacterAddedConnections = {}
function MainClass:Init(HideOtherCharacters)
    if HideOtherCharacters then
        for _, Player in next, game.Players:GetPlayers() do
            if Player ~= LocalPlayer then
                Player.Character.Parent = nil
                local CharacterConnection
                CharacterConnection = Player.CharacterAdded:Connect(function(Character)
                    wait(0.1)
                    Character.Parent = nil
                end)
                self.CharacterAddedConnections[Player] = CharacterConnection
            end
        end
        game.Players.PlayerAdded:Connect(function(Player)
            if Player ~= LocalPlayer then
                local CharacterConnection
                CharacterConnection = Player.CharacterAdded:Connect(function(Character)
                    wait(0.1)
                    Character.Parent = nil
                end)
                self.CharacterAddedConnections[Player] = CharacterConnection
            end
        end)
        game.Players.PlayerRemoving:Connect(function(Player)
            local Connection = self.CharacterAddedConnections[Player]
            if Connection then
                Connection:Disconnect()
                self.CharacterAddedConnections[Player] = nil
            end
        end)
        workspace.Main.GivePaycheck.OnClientEvent:Connect(ClaimPaycheck)
    end
end

local CashierClass = {}
CashierClass.Timeout = 10
CashierClass.Registers = {workspace.Register1, workspace.Register2, workspace.Register3}
function CashierClass:GetCustomers()
    local ValidCustomers = {}
    for _,Customer in next, workspace.Customers:GetChildren() do
        local InUse = FindChildByIndexSequence(Customer, {"Head", "InUse"})
        if InUse and InUse.Value == false and Customer:FindFirstChild("Torso") and (Customer.Torso.Velocity.Magnitude < 1 or math.round(Customer.Torso.Velocity.Z) == -15) and (Customer.HumanoidRootPart.Position - self:GetRegisterFromCustomer(Customer).Screen.Position).Magnitude < 22 and not Customer:GetAttribute("AlreadyHandled") then
            table.insert(ValidCustomers, Customer)
        end
    end
    return ValidCustomers
end

function CashierClass:GetRegisterFromCustomer(Customer)
    local BestRegister, BestDistance = nil, math.huge
    for _, Register in next, self.Registers do
        if Customer:FindFirstChild("HumanoidRootPart") and (Customer.HumanoidRootPart.Position - Register.Screen.Position).Magnitude < BestDistance then
            BestDistance = (Customer.HumanoidRootPart.Position - Register.Screen.Position).Magnitude
            BestRegister = Register
        end
    end
    return BestRegister
end

function CashierClass:GetClosestValidCustomer()
    local Customers = CashierClass:GetCustomers()
    local BestCustomer, BestDistance = nil, math.huge
    for _, Customer in next, Customers do
        if Customer:FindFirstChild("HumanoidRootPart") and LocalPlayer:DistanceFromCharacter(Customer.HumanoidRootPart.Position) < BestDistance then
            BestDistance = LocalPlayer:DistanceFromCharacter(Customer.HumanoidRootPart.Position)
            BestCustomer = Customer
        end
    end
    return BestCustomer
end

CashierClass.OrderConnection = workspace.GameService.RecivedCustomerOrder.OnClientEvent
function CashierClass:HandleCustomerDialog(Customer, Register)
    if FindChildByIndexSequence(Customer, {"Head", "DialogSimple", "Correct"}) and not CashierClass:IsInUse(Customer) then
        workspace:WaitForChild("Dialog"):FireServer("ClickedBubble", Customer.Head)
        workspace:WaitForChild("Dialog"):FireServer("ResponseSelected", Customer.Head.DialogSimple.Correct, Customer.Head)
        local OrderString
        local ClientOrderConnection
        ClientOrderConnection = self.OrderConnection:Connect(function(Order, ...)
            OrderString = Order
            ClientOrderConnection:Disconnect()
        end)
        local TimeTaken = 0
        repeat task.wait(0.1) TimeTaken += 0.1 until OrderString or TimeTaken >= self.Timeout
        if TimeTaken >= self.Timeout then
            return
        end
        Events.OrderComplete:FireServer(Customer, OrderString, Register)
        Customer:SetAttribute("AlreadyHandled", true)
                          if streamproof then
              rconsoleprint("Log: Done talking to customer.\n")
                 else
             print("Log: Done talking to customer.")
            end
    end
end

function CashierClass:CustomerHasVisibleBubble(Customer)
    local Head = Customer:FindFirstChild("Head")
    local IsVisible = false
    for i,v in pairs(LocalPlayer.PlayerGui.CustomerBubbles:GetChildren()) do
        if v.Adornee == Head and v.Enabled == true then
            IsVisible = true
        end
    end
    if Customer.Head.SimpleDialogBillboard.Enabled == true then
        return false
    end
    return IsVisible
end
function CashierClass:IsInUse(Customer)
    return FindChildByIndexSequence(Customer, {"Head", "InUse"}).Value and not CashierClass:CustomerHasVisibleBubble(Customer)
end

local CashierCoroutine = coroutine.create(function()
    while wait(1) do
            if streamproof then
             rconsoleprint("Log: Loop started\n")
              else
           print("Log: Loop started")
              end
        if LocalPlayer.Team ~= game:GetService("Teams").Cashier then
            TeleportToJob("Cashier")
        end
                         if streamproof then
                  rconsoleprint("Log: Waiting for an customer...\n")
                 else
             print("Log: Waiting for an customer...")
                    end
        local ClosestCustomer = CashierClass:GetClosestValidCustomer()
        if ClosestCustomer then
                if streamproof then
                  rconsoleprint("Log: Getting register\n")
                 else
             print("Log: Getting register")
             end
            local TargetRegister = CashierClass:GetRegisterFromCustomer(ClosestCustomer)
            if TargetRegister then
                          if streamproof then
                  rconsoleprint("Log: Walking to customer\n")
                 else
             print("Log: Walking to customer")
                    end
                WalkToPoint(TargetRegister.Border.Position + (-TargetRegister.Border.CFrame.LookVector).Unit * 5)()
                LocalPlayer.Character:PivotTo(CFrame.new(LocalPlayer.Character.HumanoidRootPart.Position, ClosestCustomer.HumanoidRootPart.Position))
                if CashierClass:IsInUse(ClosestCustomer) then
                    continue
                end
                     if streamproof then
                  rconsoleprint("Log: Done Walking.\n")
                 else
             print("Log: Done Walking.")
                    end
                CashierClass:HandleCustomerDialog(ClosestCustomer, TargetRegister)
                                       if streamproof then
                  rconsoleprint("Log: Done order!\n")
                 else
                     print("Log: Done order!")
                  end
            end
        end
    end
end)

if lowgfx then
local decalsyeeted = true -- Leaving this on makes games look shitty but the fps goes up by at least 20.
local g = game
local w = g.Workspace
local l = g.Lighting
local t = w.Terrain
t.WaterWaveSize = 0
t.WaterWaveSpeed = 0
t.WaterReflectance = 0
t.WaterTransparency = 0
l.GlobalShadows = false
l.FogEnd = 9e9
l.Brightness = 0
settings().Rendering.QualityLevel = "Level01"
for i, v in pairs(g:GetDescendants()) do
    if v:IsA("Part") or v:IsA("Union") or v:IsA("CornerWedgePart") or v:IsA("TrussPart") then
        v.Material = "Plastic"
        v.Reflectance = 0
    elseif v:IsA("Decal") or v:IsA("Texture") and decalsyeeted then
        v.Transparency = 1
    elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
        v.Lifetime = NumberRange.new(0)
    elseif v:IsA("Explosion") then
        v.BlastPressure = 1
        v.BlastRadius = 1
    elseif v:IsA("Fire") or v:IsA("SpotLight") or v:IsA("Smoke") or v:IsA("Sparkles") then
        v.Enabled = false
    elseif v:IsA("MeshPart") then
        v.Material = "Plastic"
        v.Reflectance = 0
        v.TextureID = 10385902758728957
    end
end
for i, e in pairs(l:GetChildren()) do
    if e:IsA("BlurEffect") or e:IsA("SunRaysEffect") or e:IsA("ColorCorrectionEffect") or e:IsA("BloomEffect") or e:IsA("DepthOfFieldEffect") then
        e.Enabled = false
       end
   end
end
coroutine.resume(CashierCoroutine)
MainClass:Init(true)
else
    if streamproof then
    rconsoleprint("Error: Wrong Game\n")
      else
     print("Error: Wrong Game")
     end
end

if fastmode then
   game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 22
else
   game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 16
end

while wait(30) do
local notes = {"Scripter Note: Over time the walk to target might bug abit but it should not interween on the order.","This script is undetectable.","I fogor","Best free working autofarm for work at a pizza place.","More functions soon","Made by jailedd and pvhh"}
local notepicker = notes[math.random(1,#notes)]
delay(0,function()
         if streamproof then
    rconsoleprint(notepicker .."\n")
      else
    print("Error Report: Over time the walk to target might bug abit but it should not interween on the order.")
        end
    end)
end
